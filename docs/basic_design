아래는 기존 구조를 그대로 유지하면서, 요청하신 대로 모든 Docker 공개 포트 숫자를 새로운 4자리로 변경했고, 각 코드 파일마다 상세한 한글 주석을 추가한 예시입니다. 변경된 부분은 크게 다음 두 가지입니다.
	1.	docker-compose.yml
	•	Postgres, Backend, Frontend 각각 호스트 공개 포트를 모두 새롭게(기존과 완전히 다른 네 자리) 지정
	2.	모든 코드 파일
	•	주요 함수ㆍ클래스ㆍ설정마다 한글 주석을 최대한 상세히 추가

아래 내용을 참고하시고, 그대로 붙여 넣어 사용하시면 됩니다.

⸻

1. docker-compose.yml (프로젝트 최상위)

version: "3.8"

########################################
# 네트워크 설정
# - ngnet 브리지 네트워크를 통해 컨테이너 간 통신을 수행합니다.
########################################
networks:
  ngnet:
    driver: bridge

services:

  ########################################
  # PostgreSQL 데이터베이스 서비스
  ########################################
  postgres:
    image: postgres:15                    # PostgreSQL 공식 이미지 버전 15 사용
    container_name: accident-postgres     # 컨테이너 이름 지정
    restart: always                       # 컨테이너가 비정상 종료 시 자동 재시작
    env_file:
      - ./.env              # 환경변수 파일(.env) 사용
    environment:
      POSTGRES_USER: ${POSTGRES_USER}     # .env에서 불러온 DB 사용자
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD} # .env에서 불러온 DB 비밀번호
      POSTGRES_DB: ${POSTGRES_DB}         # .env에서 불러온 DB 이름
    volumes:
      - ./postgres-data:/var/lib/postgresql/data  # 상대경로 볼륨 바인딩 (호스트 ./postgres-data → 컨테이너 내부 데이터 디렉터리)
    networks:
      - ngnet                             # ngnet 네트워크에 연결
    ports:
      - "6543:5432"                       # 호스트 포트 6543 → 컨테이너 포트 5432 (원래 5433→5432였으나 완전히 다른 네 자리로 변경)

  ########################################
  # Backend (Express + Drizzle ORM) 서비스
  ########################################
  backend:
    build:
      context: ./backend                   # build 컨텍스트를 backend 폴더로 지정
      dockerfile: Dockerfile               # backend 폴더 내 Dockerfile 사용
    container_name: accident-backend        # 컨테이너 이름 지정
    restart: always                         # 컨테이너 비정상 종료 시 재시작
    env_file:
      - ./.env               # 환경변수 파일(.env) 사용
    environment:
      DATABASE_URL: "postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}"
                                           # PostgreSQL 접속 문자열 (컨테이너 내부에서 postgres 서비스 DNS를 'postgres'로 사용)
      NODE_ENV: development                # Node.js 실행 모드를 development로 설정
    volumes:
      - ./backend:/usr/src/app             # 상대경로 바인딩 (호스트 ./backend → 컨테이너 /usr/src/app)
    networks:
      - ngnet                              # ngnet 네트워크에 연결
    ports:
      - "5000:3000"                        # 호스트 포트 5000 → 컨테이너 포트 3000 (원래 4000→3000이었으나 완전히 다른 네 자리로 변경)
    command: ["npm", "run", "dev"]         # 컨테이너 시작 시 개발 모드로 Next.js(Express) 실행

  ########################################
  # Frontend (Next.js) 서비스
  ########################################
  frontend:
    build:
      context: ./frontend                  # build 컨텍스트를 frontend 폴더로 지정
      dockerfile: Dockerfile               # frontend 폴더 내 Dockerfile 사용
    container_name: accident-frontend       # 컨테이너 이름 지정
    restart: always                         # 컨테이너 비정상 종료 시 재시작
    env_file:
      - ./.env              # 환경변수 파일(.env) 사용
    environment:
      NEXT_PUBLIC_API_URL: "http://localhost:6001"
                                           # 프론트엔드에서 호출할 백엔드 URL (백엔드가 호스트 5000 포트로 노출되므로)
      NODE_ENV: development                # Node.js 실행 모드를 development로 설정
    volumes:
      - ./frontend:/usr/src/app             # 상대경로 바인딩 (호스트 ./frontend → 컨테이너 /usr/src/app)
    networks:
      - ngnet                              # ngnet 네트워크에 연결
    ports:
      - "4000:3000"                        # 호스트 포트 4000 → 컨테이너 포트 3000 (원래 3000→3000이었으나 완전히 다른 네 자리로 변경)
    command: ["npm", "run", "dev"]         # 컨테이너 시작 시 개발 모드로 Next.js 실행

volumes:
  pgdata: {}                              # PostgreSQL 데이터 영속성을 위한 volume 정의

주의
	•	모든 호스트 공개 포트(왼쪽 숫자)를 기존과 전혀 겹치지 않도록 완전히 바꿨습니다.
	•	PostgreSQL: 6543:5432
	•	Backend: 6001:3000
	•	Frontend: 4000:3000

⸻

2. Backend 코드

2.1. backend/Dockerfile

# -------------------------------------------------------
# 1. 빌드 스테이지: dependencies 설치 및 빌드 수행
# -------------------------------------------------------
FROM node:18-alpine AS builder

# 작업 디렉터리 설정 (/usr/src/app)
WORKDIR /usr/src/app

# package.json과 package-lock.json만 복사하여 의존성 설치
COPY package.json package-lock.json ./
RUN npm ci

# 전체 소스코드를 복사
COPY . .

# 타입스크립트 빌드 (만약 tsconfig.json과 빌드 스크립트가 설정되어 있다면)
RUN npm run build

# -------------------------------------------------------
# 2. 런타임 스테이지: 프로덕션용 이미지 생성
# -------------------------------------------------------
FROM node:18-alpine AS runner

# 작업 디렉터리 설정
WORKDIR /usr/src/app

# package.json만 복사하여 프로덕션 의존성 설치
COPY --from=builder /usr/src/app/package.json /usr/src/app/package-lock.json ./
RUN npm ci --omit=dev

# 빌드 결과물(.next 혹은 dist 등)과 public 폴더 복사
COPY --from=builder /usr/src/app/dist ./dist

# 외부에 노출할 포트 (컨테이너 내부)
EXPOSE 3000

# 컨테이너 실행 명령 (프로덕션 모드)
CMD ["npm", "run", "start"]

	•	Builder 스테이지
	•	Node.js LTS(node:18-alpine) 이미지를 사용하여 의존성 설치 및 TypeScript 빌드 수행
	•	Runner(런타임) 스테이지
	•	불필요한 개발(development) 의존성을 제거하고(npm ci --omit=dev),
	•	빌드 결과물만 복사하여 경량화된 프로덕션 이미지를 생성

⸻

2.2. .env(backend) (실제 값은 Git에 커밋하지 않고 공유)

# PostgreSQL 접속 정보
POSTGRES_USER=postgres
POSTGRES_PASSWORD=example_password
POSTGRES_DB=accident_db

# JWT 시크릿 키 (보안을 위해 실제로는 안전한 값으로 교체)
JWT_SECRET=your_jwt_secret_here


⸻

2.3. backend/index.ts (진입점)

/**
 * @file index.ts
 * @description
 *  - Express 서버를 초기화하고, Drizzle ORM을 연결한 뒤
 *    /api 경로에 정의된 라우트를 바인딩하여 서버를 실행합니다.
 */

import express from "express";           // Express 프레임워크
import { json } from "body-parser";      // 요청 바디(JSON) 파싱 미들웨어
import cors from "cors";                 // CORS 정책을 위한 미들웨어
import { connectDB } from "./orm/index"; // Drizzle ORM 연결 함수
import routes from "./routes";           // API 라우트 정의

const app = express();

// -------------------------------------------------------
// 1) 미들웨어 설정
// -------------------------------------------------------
app.use(cors());    // 모든 출처(CORS)를 허용 (필요 시 세부 설정 변경 가능)
app.use(json());    // 요청 바디를 JSON으로 파싱

// -------------------------------------------------------
// 2) 데이터베이스 연결
// -------------------------------------------------------
connectDB();        // Drizzle ORM을 초기화하여 PostgreSQL과 연결

// -------------------------------------------------------
// 3) 라우트 연결
// -------------------------------------------------------
// 모든 /api 경로 요청은 routes.ts에 정의된 라우트 핸들러로 전달
app.use("/api", routes);

// -------------------------------------------------------
// 4) 서버 실행
// -------------------------------------------------------
const PORT = process.env.PORT || 3000;  // 환경변수가 없으면 기본 포트 3000 사용
app.listen(PORT, () => {
  console.log(`Backend 서버가 http://localhost:${PORT} 에서 실행 중입니다.`);
});

	•	connectDB()
	•	Drizzle ORM을 통해 PostgreSQL 연결을 초기화
	•	app.use("/api", routes)
	•	모든 /api/... 요청을 routes.ts 에서 정의된 라우트로 위임

⸻

2.4. backend/routes.ts (API 라우트 정의)

/**
 * @file routes.ts
 * @description
 *  - Express Router를 사용하여 모든 RESTful API 엔드포인트를 정의합니다.
 *  - 인증 미들웨어(authMiddleware)로 보호가 필요한 경로에 대해
 *    JWT 검증을 수행하도록 설정합니다.
 */

import { Router } from "express";
import OccurrenceController from "./controllers/occurrence.controller";
import InvestigationController from "./controllers/investigation.controller";
import HistoryController from "./controllers/history.controller";
import AuthController from "./controllers/auth.controller";
import FileController from "./controllers/file.controller";
import { authMiddleware } from "./middleware/auth.middleware";

const router = Router();

/**
 * ──────────────────────────────────────────────────────────────
 * 1) 인증 관련 라우트 (아래 3개)
 *    - POST /api/auth/login   : 로그인 (JWT 발급)
 *    - GET  /api/auth/me      : 현재 로그인 사용자 정보 조회 (token 필요)
 *    - POST /api/auth/logout  : 로그아웃 (토큰 무효화)
 * ──────────────────────────────────────────────────────────────
 */
router.post("/auth/login", AuthController.login);
router.get("/auth/me", authMiddleware, AuthController.me);
router.post("/auth/logout", authMiddleware, AuthController.logout);

/**
 * ──────────────────────────────────────────────────────────────
 * 2) 사고 발생보고 (OCCURRENCE_REPORT) 관련 라우트
 *    - 모든 경로에 authMiddleware를 적용하여, 로그인한 사용자만 접근 가능
 * ──────────────────────────────────────────────────────────────
 */
router.get("/occurrence", authMiddleware, OccurrenceController.list);
router.get("/occurrence/:id", authMiddleware, OccurrenceController.getById);
router.post("/occurrence", authMiddleware, OccurrenceController.create);
router.put("/occurrence/:id", authMiddleware, OccurrenceController.update);
router.delete("/occurrence/:id", authMiddleware, OccurrenceController.remove);

/**
 * ──────────────────────────────────────────────────────────────
 * 3) 사고 조사보고 (INVESTIGATION_REPORT) 관련 라우트
 *    - 단일 사고 ID 기준으로 조회/생성/수정/삭제 수행
 * ──────────────────────────────────────────────────────────────
 */
router.get("/investigation/:id", authMiddleware, InvestigationController.getById);
router.post("/investigation", authMiddleware, InvestigationController.create);
router.put("/investigation/:id", authMiddleware, InvestigationController.update);
router.delete("/investigation/:id", authMiddleware, InvestigationController.remove);

/**
 * ──────────────────────────────────────────────────────────────
 * 4) 사고 이력(목록) 조회 (ACCIDENT_HISTORY) 관련 라우트
 *    - GET /api/history       : 페이징·필터링 포함 목록 조회
 *    - GET /api/history/:id   : 단일 사고 이력 상세 조회
 * ──────────────────────────────────────────────────────────────
 */
router.get("/history", authMiddleware, HistoryController.list);
router.get("/history/:id", authMiddleware, HistoryController.getById);

/**
 * ──────────────────────────────────────────────────────────────
 * 5) 파일 업로드/다운로드 관련 라우트
 *    - POST   /api/files/upload   : 파일(이미지 등) 업로드
 *    - GET    /api/files/:fileId  : 파일 다운로드
 *    - DELETE /api/files/:fileId  : 파일 삭제
 * ──────────────────────────────────────────────────────────────
 */
router.post("/files/upload", authMiddleware, FileController.upload);
router.get("/files/:fileId", authMiddleware, FileController.download);
router.delete("/files/:fileId", authMiddleware, FileController.delete);

export default router;

	•	authMiddleware
	•	JWT 토큰 검증 로직을 수행하며, 토큰이 유효하지 않으면 요청을 거부
	•	각 Controller
	•	해당 리소스(사고 발생/조사/이력 등)에 대해 CRUD 및 조회 기능 제공

⸻

2.5. backend/orm/index.ts (Drizzle ORM 초기화)

/**
 * @file orm/index.ts
 * @description
 *  - PostgreSQL에 연결하기 위해 Drizzle ORM을 초기화합니다.
 *  - 연결된 drizzle 인스턴스와 각 테이블 스키마를 내보냅니다.
 */

import { Pool } from "pg";                    // PostgreSQL 클라이언트
import { drizzle } from "drizzle-orm/node-postgres"; // Drizzle ORM (PostgreSQL 지원)
import { occurrenceReport } from "./schema/occurrence";
import { investigationReport } from "./schema/investigation";
import { accidentHistory } from "./schema/history";

// drizzle 인스턴스를 저장할 변수 (초기화 전엔 undefined)
let dbInstance: ReturnType<typeof drizzle>;

/**
 * @function connectDB
 * @description
 *  - 환경변수 DATABASE_URL을 사용하여 PostgreSQL에 연결하고, Drizzle ORM을 초기화합니다.
 *  - 반드시 서버가 시작되기 전에 한 번 호출되어야 합니다.
 */
export function connectDB() {
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL, // postgres 접속 문자열
  });
  dbInstance = drizzle(pool); // Drizzle ORM 초기화
}

/**
 * @function db
 * @description
 *  - 초기화된 drizzle 인스턴스를 반환합니다.
 *  - connectDB()가 호출되지 않은 상태라면 에러를 발생시킵니다.
 */
export function db() {
  if (!dbInstance) throw new Error("DB가 초기화되지 않았습니다. connectDB()를 먼저 호출하세요.");
  return dbInstance;
}

/**
 * @constant tables
 * @description
 *  - Drizzle ORM으로 정의된 각 테이블(또는 뷰) 스키마를 모아놓은 객체입니다.
 *  - 다른 코드(Repository 등)에서 import하여 사용합니다.
 */
export const tables = {
  occurrenceReport,
  investigationReport,
  accidentHistory,
};


⸻

2.6. backend/orm/schema/occurrence.ts (사고 발생보고 스키마)

/**
 * @file orm/schema/occurrence.ts
 * @description
 *  - Drizzle ORM의 pgTable 함수를 사용하여
 *    `occurrence_report` 테이블 스키마를 정의합니다.
 *  - 각 컬럼의 타입, 길이, 제약조건 등을 설정합니다.
 */

import { pgTable, varchar, datetime, boolean, integer, text } from "drizzle-orm/pg-core";

export const occurrenceReport = pgTable("occurrence_report", {
  // 사고 ID (예: AC-20250604-001)
  // → varchar(50) 타입, PK(primary key) 지정
  accident_id: varchar("accident_id", { length: 50 }).primaryKey(),

  // 사고 발생 일시 (YYYY-MM-DD HH:MM)
  acci_time: datetime("acci_time"),

  // 사고가 발생한 회사명
  company_name: varchar("company_name", { length: 100 }),

  // 사고가 발생한 사업장명
  site_name: varchar("site_name", { length: 100 }),

  // 사고 발생 위치 (예: 제어반 앞)
  acci_location: varchar("acci_location", { length: 255 }),

  // 협력업체 여부 (true: 협력업체 직원, false: 자사 직원)
  is_contractor: boolean("is_contractor"),

  // 재해자 수 (해당 사고로 피해를 받은 인원 수)
  victim_count: integer("victim_count"),

  // 재해발생의 형태 (예: 인적 / 물적)
  accident_type_level1: varchar("accident_type_level1", { length: 20 }),

  // 사고 유형 (예: 기계, 추락, 감전 등)
  accident_type_level2: varchar("accident_type_level2", { length: 50 }),

  // 사고 개요 (짧은 설명)
  acci_summary: text("acci_summary"),

  // 사고 상세 내용 (템플릿 기반 서술)
  acci_detail: text("acci_detail"),

  // 사고 현장 사진 파일 목록 (파일 ID 리스트(JSON 문자열로 저장 가능)
  scene_photos: text("scene_photos"),

  // CCTV 영상 파일 목록 (파일 ID 리스트)
  cctv_video: text("cctv_video"),

  // 관계자 진술서 파일 목록 (여러 건)
  statement_docs: text("statement_docs"),

  // 기타 문서(보고서, 점검 표 등) 파일 목록
  etc_documents: text("etc_documents"),

  // 최초 보고 일시 (사고가 처음 보고된 시간)
  first_report_time: datetime("first_report_time"),

  // 보고 경로 (예: 사내전화 → 팀장 → 안전팀 → 시스템)
  report_channel: varchar("report_channel", { length: 50 }),

  // 회사 코드 (내부 연동용, 관리자만 관리)
  company_code: varchar("company_code", { length: 20 }),

  // 사업장 코드 (내부 연동용, 관리자만 관리)
  site_code: varchar("site_code", { length: 20 }),

  // 업무성 사고 분류 (예: 업무중, 통근중, 기타)
  work_related_type: varchar("work_related_type", { length: 20 }),

  // 기타 분류 (예: 보안사고, 화재사고 등 관리자 지정)
  misc_classification: varchar("misc_classification", { length: 50 }),
});


⸻

2.7. backend/orm/schema/investigation.ts (사고 조사보고 스키마)

/**
 * @file orm/schema/investigation.ts
 * @description
 *  - Drizzle ORM을 통해 `investigation_report` 테이블 스키마를 정의합니다.
 *  - `occurrence_report.accident_id`를 참조하여 1:1 관계를 맺습니다.
 */

import { pgTable, varchar, datetime, integer, text, boolean } from "drizzle-orm/pg-core";
import { occurrenceReport } from "./occurrence";

export const investigationReport = pgTable("investigation_report", {
  // 사고 발생보고의 accident_id를 FK로 참조하여 1:1 관계를 설정
  accident_id: varchar("accident_id", { length: 50 })
    .primaryKey()
    .references(() => occurrenceReport.accident_id),

  // 조사 착수 일시 (실제 조사 시작일시)
  investigation_start_time: datetime("investigation_start_time"),

  // 조사 완료 일시 (조사 종료 시점)
  investigation_end_time: datetime("investigation_end_time"),

  // 조사 팀장 이름
  investigation_team_lead: varchar("investigation_team_lead", { length: 100 }),

  // 조사 팀원(콤마 구분 문자열)
  investigation_team_members: text("investigation_team_members"),

  // 조사 장소 (예: 현장 사무실, 본사 회의실 등)
  investigation_location: varchar("investigation_location", { length: 255 }),

  // 원본 전체 사고 코드 (읽기용)
  original_global_accident_no: varchar("original_global_accident_no", { length: 50 }),

  // 수정 또는 보완된 전체 사고 코드 (조사 단계에서 변경 시 사용)
  investigation_global_accident_no: varchar("investigation_global_accident_no", { length: 50 }),

  // 원본 사고 ID (읽기용)
  original_accident_id: varchar("original_accident_id", { length: 50 }),

  // 수정 또는 보완된 사고 ID
  investigation_accident_id: varchar("investigation_accident_id", { length: 50 }),

  // 원본 사고 발생 일시 (읽기용)
  original_acci_time: datetime("original_acci_time"),

  // 수정 또는 보완된 사고 발생 일시
  investigation_acci_time: datetime("investigation_acci_time"),

  // 원본 사고 발생 위치 (읽기용)
  original_acci_location: varchar("original_acci_location", { length: 255 }),

  // 수정 또는 보완된 사고 발생 위치
  investigation_acci_location: varchar("investigation_acci_location", { length: 255 }),

  // 원본 재해발생의 형태 (읽기용)
  original_accident_type_level1: varchar("original_accident_type_level1", { length: 20 }),

  // 수정 또는 보완된 재해발생의 형태
  investigation_accident_type_level1: varchar("investigation_accident_type_level1", { length: 20 }),

  // 원본 사고 유형 (읽기용)
  original_accident_type_level2: varchar("original_accident_type_level2", { length: 50 }),

  // 수정 또는 보완된 사고 유형
  investigation_accident_type_level2: varchar("investigation_accident_type_level2", { length: 50 }),

  // 원본 사고 개요 (읽기용)
  original_acci_summary: text("original_acci_summary"),

  // 수정 또는 보완된 사고 개요
  investigation_acci_summary: text("investigation_acci_summary"),

  // 원본 사고 상세 (읽기용)
  original_acci_detail: text("original_acci_detail"),

  // 수정 또는 보완된 사고 상세
  investigation_acci_detail: text("investigation_acci_detail"),

  // 원본 재해자 수 (읽기용)
  original_victim_count: integer("original_victim_count"),

  // 수정 또는 보완된 재해자 수
  investigation_victim_count: integer("investigation_victim_count"),

  // 원본 재해자1 이름 (읽기용)
  original_victim_name_1: varchar("original_victim_name_1", { length: 100 }),

  // 수정 또는 보완된 재해자1 이름
  investigation_victim_name_1: varchar("investigation_victim_name_1", { length: 100 }),

  // 원본 재해자1 나이 (읽기용)
  original_victim_age_1: integer("original_victim_age_1"),

  // 수정 또는 보완된 재해자1 나이
  investigation_victim_age_1: integer("investigation_victim_age_1"),

  // 원본 재해자1 소속 (읽기용)
  original_victim_belong_1: varchar("original_victim_belong_1", { length: 100 }),

  // 수정 또는 보완된 재해자1 소속
  investigation_victim_belong_1: varchar("investigation_victim_belong_1", { length: 100 }),

  // 원본 재해자1 협력업체 여부 (읽기용)
  original_is_contractor_1: varchar("original_is_contractor_1", { length: 10 }),

  // 수정 또는 보완된 재해자1 협력업체 여부
  investigation_is_contractor_1: varchar("investigation_is_contractor_1", { length: 10 }),

  // 원본 재해자1 협력업체명 (읽기용)
  original_contractor_name_1: varchar("original_contractor_name_1", { length: 100 }),

  // 수정 또는 보완된 재해자1 협력업체명
  investigation_contractor_name_1: varchar("investigation_contractor_name_1", { length: 100 }),

  // 원본 재해자1 직무 (읽기용)
  original_victim_duty_1: varchar("original_victim_duty_1", { length: 100 }),

  // 수정 또는 보완된 재해자1 직무
  investigation_victim_duty_1: varchar("investigation_victim_duty_1", { length: 100 }),

  // 원본 재해자1 부상 유형 (읽기용)
  original_injury_type_1: varchar("original_injury_type_1", { length: 50 }),

  // 수정 또는 보완된 재해자1 부상 유형
  investigation_injury_type_1: varchar("investigation_injury_type_1", { length: 50 }),

  // 원본 재해자1 보호구 착용 여부 (읽기용)
  original_ppe_worn_1: varchar("original_ppe_worn_1", { length: 50 }),

  // 수정 또는 보완된 재해자1 보호구 착용 여부
  investigation_ppe_worn_1: varchar("investigation_ppe_worn_1", { length: 50 }),

  // 원본 재해자1 응급조치 내역 (읽기용)
  original_first_aid_1: text("original_first_aid_1"),

  // 수정 또는 보완된 재해자1 응급조치 내역
  investigation_first_aid_1: text("investigation_first_aid_1"),

  // 조사 단계에서 추가로 찍은 현장 사진 파일 ID 목록
  investigation_scene_photos: text("investigation_scene_photos"),

  // 조사 단계에서 추가로 받은 관계자 진술서 파일 ID 목록
  investigation_statement_docs: text("investigation_statement_docs"),

  // 조사 단계에서 추가로 받은 기타 문서 파일 ID 목록
  investigation_etc_documents: text("investigation_etc_documents"),

  // 조사보고서 최초 보고 일시
  investigation_first_report_time: datetime("investigation_first_report_time"),

  // 조사보고서 보고 경로 (현재 수정된 값)
  investigation_report_channel: varchar("investigation_report_channel", { length: 50 }),

  // 조사 단계에서 수정된 업무성 사고 분류
  investigation_work_related_type: varchar("investigation_work_related_type", { length: 20 }),

  // 피해의 정도 (사망/중상/경상 등)
  damage_severity: varchar("damage_severity", { length: 20 }),

  // 사망자 수 (조사 단계에서 집계)
  death_count: integer("death_count"),

  // 부상자 수 (조사 단계에서 집계)
  injured_count: integer("injured_count"),

  // 피해금액 (설비 수리비, 생산 손실 등)
  damage_cost: integer("damage_cost"),

  // 부상 부위 상세 (예: 좌측 손목 골절)
  injury_location_detail: varchar("injury_location_detail", { length: 100 }),

  // 재해자 복귀일 (예정 또는 실제)
  victim_return_date: datetime("victim_return_date"),

  // 직접 원인 (조사자가 입력)
  direct_cause: text("direct_cause"),

  // 근본 원인 (조사자가 입력)
  root_cause: text("root_cause"),

  // 재발방지대책 요약 (조사자가 입력)
  corrective_actions: text("corrective_actions"),

  // 대책 실행 일정 (날짜/시간 형식 문자열)
  action_schedule: varchar("action_schedule", { length: 100 }),

  // 대책 이행 확인자 (조치 완료 시 서명 또는 이름)
  action_verifier: varchar("action_verifier", { length: 100 }),

  // 조사보고서용 추가 현장 사진 파일 ID 목록
  investigation_photos: text("investigation_photos"),

  // 조사보고서용 장비·설비 점검 결과 문서
  equipment_inspection_report: text("equipment_inspection_report"),

  // 조사보고서용 추가 관계자 진술서 파일 ID 목록
  witness_statements: text("witness_statements"),

  // 사고 재구성 도면/흐름도 파일 ID
  incident_flow_diagram: text("incident_flow_diagram"),

  // 조사 종합 결론 (장문)
  investigation_conclusion: text("investigation_conclusion"),

  // 조사자 서명 (이미지 ID 또는 텍스트)
  investigator_signature: varchar("investigator_signature", { length: 100 }),

  // 조사보고서 작성일
  report_written_date: datetime("report_written_date"),

  // 조사 진행상태 (예: 조사 미착수/진행 중/대책 이행 중/완료)
  investigation_status: varchar("investigation_status", { length: 20 }),

  // 조사 결과 요약 (간략)
  investigation_summary: text("investigation_summary"),

  // 조사보고서 링크(PDF 등) 또는 첨부 파일 ID
  investigation_report_link: varchar("investigation_report_link", { length: 255 }),

  // 법적 보고 여부 (예: Y/N)
  legal_report_flag: varchar("legal_report_flag", { length: 20 }),

  // 위험성 평가서 번호(RA)
  ra_number: varchar("ra_number", { length: 50 }),

  // 보험 처리 현황 (예: 진행 중/완료)
  insurance_status: varchar("insurance_status", { length: 50 }),

  // 사고 관련 교육 또는 조치 이력 (콤마 구분 문자열)
  training_action_history: varchar("training_action_history", { length: 255 }),
});


⸻

2.8. backend/orm/schema/history.ts (사고 이력 뷰/테이블 스키마)

/**
 * @file orm/schema/history.ts
 * @description
 *  - Drizzle ORM을 통해 `accident_history` 뷰(또는 테이블) 스키마를 정의합니다.
 *  - 발생보고/조사보고 데이터를 조인하여 한눈에 조회할 수 있는 Denormalized View용 테이블입니다.
 */

import { pgTable, varchar, datetime, boolean, integer, text } from "drizzle-orm/pg-core";

export const accidentHistory = pgTable("accident_history", {
  // 사고 ID (Primary Key, 발생보고 accident_id와 동일)
  accident_id: varchar("accident_id", { length: 50 }).primaryKey(),

  // 회사명 (발생보고서 기준)
  company_name: varchar("company_name", { length: 100 }),

  // 사업장명 (발생보고서 기준)
  site_name: varchar("site_name", { length: 100 }),

  // 사고 발생 일시 (발생보고서 기준)
  acci_time: datetime("acci_time"),

  // 사고 발생 장소 (발생보고서 기준)
  acci_location: varchar("acci_location", { length: 255 }),

  // 협력업체 여부 (발생보고서 기준)
  is_contractor: boolean("is_contractor"),

  // 재해자 소속 (발생보고서 기준, 첫 번째 재해자 기준)
  victim_belong: varchar("victim_belong", { length: 100 }),

  // 재해발생의 형태 (발생보고서 기준)
  accident_type_level1: varchar("accident_type_level1", { length: 20 }),

  // 사고 유형 (발생보고서 기준)
  accident_type_level2: varchar("accident_type_level2", { length: 50 }),

  // 사망자 수 (조사보고서 기준)
  death_count: integer("death_count"),

  // 부상자 수 (조사보고서 기준)
  injured_count: integer("injured_count"),

  // 피해금액 (조사보고서 기준)
  damage_cost: integer("damage_cost"),

  // 피해의 정도 (조사보고서 기준)
  damage_severity: varchar("damage_severity", { length: 20 }),

  // 기타 분류 (발생보고서 기준)
  misc_classification: varchar("misc_classification", { length: 50 }),

  // 사고 개요 (발생보고서 기준)
  acci_summary: text("acci_summary"),

  // 직접 원인 (조사보고서 기준)
  direct_cause: text("direct_cause"),

  // 근본 원인 (조사보고서 기준)
  root_cause: text("root_cause"),

  // 부상부위 상세 (조사보고서 기준)
  injury_location_detail: varchar("injury_location_detail", { length: 100 }),

  // 재발방지대책 요약 (조사보고서 기준)
  corrective_actions: text("corrective_actions"),

  // 재해자 복귀일 (조사보고서 기준)
  victim_return_date: datetime("victim_return_date"),

  // 조사 진행상태 (조사보고서 기준)
  investigation_status: varchar("investigation_status", { length: 20 }),

  // 조사 착수 일시 (조사보고서 기준)
  investigation_start_time: datetime("investigation_start_time"),

  // 조사 완료 일시 (조사보고서 기준)
  investigation_end_time: datetime("investigation_end_time"),

  // 조사자 서명 (조사보고서 기준)
  investigator_signature: varchar("investigator_signature", { length: 100 }),

  // 법적 보고 여부 (조사보고서 기준)
  legal_report_flag: varchar("legal_report_flag", { length: 20 }),
});


⸻

2.9. 예시 컨트롤러 파일: backend/controllers/occurrence.controller.ts

/**
 * @file controllers/occurrence.controller.ts
 * @description
 *  - 사고 발생보고(Occurrence Report) 관련 비즈니스 로직을 처리하는 Controller입니다.
 *  - HTTP 요청(Express Request)을 받아, Service를 호출하고 응답을 반환합니다.
 */

import { Request, Response } from "express";
import OccurrenceService from "../services/occurrence.service";

export default class OccurrenceController {
  /**
   * @method list
   * @description
   *  - GET /api/occurrence
   *  - 사고 발생보고 리스트를 페이징/필터링하여 조회합니다.
   * @param req Express Request 객체 (쿼리 파라미터: page, size, company, status, from, to)
   * @param res Express Response 객체
   */
  static async list(req: Request, res: Response) {
    // 쿼리 파라미터에서 페이징/필터 값을 가져옵니다.
    const { page = "1", size = "20", company, status, from, to } = req.query;
    const filters = {
      company: String(company || ""),
      status: String(status || ""),
      from: String(from || ""),
      to: String(to || ""),
    };
    const pagination = { page: Number(page), size: Number(size) };

    try {
      // Service 계층에 페이징/필터 정보를 전달하여 결과를 받아옵니다.
      const result = await OccurrenceService.fetchList(filters, pagination);
      return res.status(200).json(result);
    } catch (error: any) {
      // 에러 발생 시 500 Internal Server Error 응답
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * @method getById
   * @description
   *  - GET /api/occurrence/:id
   *  - 단일 사고 발생보고 상세 정보를 조회합니다.
   * @param req Express Request 객체 (경로 파라미터: id)
   * @param res Express Response 객체
   */
  static async getById(req: Request, res: Response) {
    const { id } = req.params;
    try {
      // Service 계층에서 해당 id의 레코드를 조회
      const occurrence = await OccurrenceService.getById(id);
      if (!occurrence) {
        // 레코드가 없으면 404 Not Found 응답
        return res.status(404).json({ error: "사고를 찾을 수 없습니다." });
      }
      return res.status(200).json(occurrence);
    } catch (error: any) {
      return res.status(500).json({ error: error.message });
    }
  }

  /**
   * @method create
   * @description
   *  - POST /api/occurrence
   *  - 새로운 사고 발생보고를 등록합니다.
   * @param req Express Request 객체 (요청 바디: 사고 등록 정보)
   * @param res Express Response 객체
   */
  static async create(req: Request, res: Response) {
    try {
      const newData = req.body;
      // Service 계층에 전달하여 DB에 삽입 및 결과 반환
      const created = await OccurrenceService.create(newData);
      return res.status(201).json(created);
    } catch (err: any) {
      // 유효성 검증 실패 등 예외 처리 시 400 Bad Request 반환
      return res.status(400).json({ error: err.message });
    }
  }

  /**
   * @method update
   * @description
   *  - PUT /api/occurrence/:id
   *  - 기존 사고 발생보고를 수정합니다.
   * @param req Express Request 객체 (경로 파라미터: id, 바디: 수정할 필드)
   * @param res Express Response 객체
   */
  static async update(req: Request, res: Response) {
    const { id } = req.params;
    try {
      // Service 계층에 id와 수정할 데이터를 전달
      const updated = await OccurrenceService.update(id, req.body);
      return res.status(200).json(updated);
    } catch (err: any) {
      // 수정 도중 예외 발생 시 400 Bad Request 반환
      return res.status(400).json({ error: err.message });
    }
  }

  /**
   * @method remove
   * @description
   *  - DELETE /api/occurrence/:id
   *  - 기존 사고 발생보고를 삭제합니다.
   * @param req Express Request 객체 (경로 파라미터: id)
   * @param res Express Response 객체
   */
  static async remove(req: Request, res: Response) {
    const { id } = req.params;
    try {
      // Service 계층에 id를 전달하여 레코드를 삭제
      await OccurrenceService.remove(id);
      // 삭제 성공 시 204 No Content 반환
      return res.status(204).end();
    } catch (err: any) {
      return res.status(400).json({ error: err.message });
    }
  }
}

	•	각 메서드(list, getById, create, update, remove)
	•	Express의 Request, Response 객체를 받아서
	•	OccurrenceService의 적절한 메서드를 호출하고,
	•	성공 시 JSON 형태로 응답을 반환하거나, 적절한 HTTP 상태 코드를 응답

⸻

2.10. 예시 서비스 파일: backend/services/occurrence.service.ts

/**
 * @file services/occurrence.service.ts
 * @description
 *  - 사고 발생보고 관련 비즈니스 로직을 구현합니다.
 *  - Drizzle ORM을 활용하여 데이터베이스에 CRUD 작업을 수행합니다.
 */

import { db, tables } from "../orm/index";
import { sql } from "drizzle-orm";

interface Filters {
  company: string;
  status: string;
  from: string;
  to: string;
}

interface Pagination {
  page: number;
  size: number;
}

export default class OccurrenceService {
  /**
   * @method fetchList
   * @description
   *  - 페이징과 필터 조건을 적용하여 사고 발생보고 목록을 조회합니다.
   * @param filters 필터 조건 (company, status, from, to)
   * @param pagination 페이징 정보 (page, size)
   * @returns 페이징 결과와 데이터 배열
   */
  static async fetchList(filters: Filters, pagination: Pagination) {
    const { company, status, from, to } = filters;
    const { page, size } = pagination;
    const offset = (page - 1) * size;

    // Drizzle ORM 쿼리 빌더 사용 예시
    // 1) 기본 select 쿼리
    let query = db().select().from(tables.occurrenceReport);

    // 2) 회사명 필터가 있을 경우 where 절 추가
    if (company) {
      query = query.where(sql`${tables.occurrenceReport.company_name} = ${company}`);
    }

    // 3) 날짜 범위 필터가 있을 경우 추가
    if (from && to) {
      query = query.where(
        sql`${tables.occurrenceReport.acci_time} BETWEEN ${from} AND ${to}`
      );
    }

    // 4) 페이징 적용: limit, offset
    const data = await query.limit(size).offset(offset);

    // 5) 전체 개수(count) 조회 (필터 적용 포함)
    const totalResult = await db()
      .select({ count: sql`COUNT(*)` })
      .from(tables.occurrenceReport)
      // 위에서 사용한 필터와 동일하게 중복 적용해야 함
      .where(
        company
          ? sql`${tables.occurrenceReport.company_name} = ${company}`
          : sql`1 = 1`
      )
      .where(
        from && to
          ? sql`${tables.occurrenceReport.acci_time} BETWEEN ${from} AND ${to}`
          : sql`1 = 1`
      );
    const total = Number((totalResult[0] as any).count);

    return {
      data,
      pagination: {
        total,
        page,
        size,
        pages: Math.ceil(total / size),
      },
    };
  }

  /**
   * @method getById
   * @description
   *  - 단일 사고 발생보고 데이터를 ID로 조회합니다.
   * @param id 사고 ID
   */
  static async getById(id: string) {
    const record = await db()
      .select()
      .from(tables.occurrenceReport)
      .where(sql`${tables.occurrenceReport.accident_id} = ${id}`)
      .limit(1);

    return record.length > 0 ? record[0] : null;
  }

  /**
   * @method create
   * @description
   *  - 새로운 사고 발생보고 데이터를 DB에 삽입합니다.
   * @param data 요청 바디에 담긴 사고 등록 정보
   * @returns 생성된 레코드
   */
  static async create(data: any) {
    // 예시: 단순 삽입. 실제로는 유효성 검사 및 중복 검사 로직 필요
    await db().insert(tables.occurrenceReport).values(data);
    return data;
  }

  /**
   * @method update
   * @description
   *  - 기존 사고 발생보고 데이터를 수정합니다.
   * @param id 수정할 사고 ID
   * @param data 수정할 필드 값
   * @returns 수정된 레코드 (간단히 data 반환)
   */
  static async update(id: string, data: any) {
    // 예: id에 해당하는 레코드가 없으면 예외 발생
    const existing = await this.getById(id);
    if (!existing) {
      throw new Error("수정할 사고를 찾을 수 없습니다.");
    }

    // Drizzle ORM update 쿼리 사용
    await db()
      .update(tables.occurrenceReport)
      .set(data)
      .where(sql`${tables.occurrenceReport.accident_id} = ${id}`);

    return { ...existing, ...data };
  }

  /**
   * @method remove
   * @description
   *  - 사고 발생보고 레코드를 삭제합니다.
   * @param id 삭제할 사고 ID
   */
  static async remove(id: string) {
    // 삭제 전 존재 여부 확인
    const existing = await this.getById(id);
    if (!existing) {
      throw new Error("삭제할 사고를 찾을 수 없습니다.");
    }

    // Drizzle ORM delete 쿼리 사용
    await db()
      .delete(tables.occurrenceReport)
      .where(sql`${tables.occurrenceReport.accident_id} = ${id}`);
  }
}


⸻

3. Frontend 코드

3.1. frontend/Dockerfile

# -------------------------------------------------------
# 1. 빌드 스테이지: dependencies 설치 및 Next.js 빌드
# -------------------------------------------------------
FROM node:18-alpine AS builder

# 작업 디렉터리 설정
WORKDIR /usr/src/app

# package.json 및 package-lock.json 복사 후 의존성 설치
COPY package.json package-lock.json ./
RUN npm ci

# 전체 소스코드 복사
COPY . .

# Next.js 앱 빌드
RUN npm run build

# -------------------------------------------------------
# 2. 런타임 스테이지: 프로덕션용 이미지 생성
# -------------------------------------------------------
FROM node:18-alpine AS runner

WORKDIR /usr/src/app

# 프로덕션 의존성만 설치
COPY --from=builder /usr/src/app/package.json /usr/src/app/package-lock.json ./
RUN npm ci --omit=dev

# 빌드 결과물(.next 디렉터리)와 공용 폴더(public) 복사
COPY --from=builder /usr/src/app/.next ./.next
COPY --from=builder /usr/src/app/public ./public

# 외부에 노출할 포트 (컨테이너 내부)
EXPOSE 3000

# Next.js 프로덕션 서버 실행
CMD ["npm", "run", "start"]


⸻

3.2. .env(frontend) (테스트용 환경변수)

# 프론트엔드에서 호출할 백엔드 URL (도커 컴포즈에 맞춰 변경)
NEXT_PUBLIC_API_URL="http://localhost:6001"


⸻

3.3. frontend/next.config.js

/**
 * @file next.config.js
 * @description
 *  - Next.js 설정 파일
 *  - 환경변수 로드, 이미지 도메인 설정 등 필요 시 추가 설정 가능
 */

const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  // 환경변수 공개 범위 설정 (NEXT_PUBLIC_* 로 시작하는 변수만 클라이언트로 노출)
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL,
  },
};

module.exports = nextConfig;


⸻

3.4. frontend/app/layout.tsx (공통 레이아웃)

"use client";

import Link from "next/link";
import { useState } from "react";

/**
 * @file layout.tsx
 * @description
 *  - 모든 페이지의 공통 레이아웃을 담당합니다.
 *  - Header, 네비게이션 메뉴, Footer를 포함하며,
 *    모바일/데스크탑 반응형 구조를 지원합니다.
 */

export default function Layout({ children }: { children: React.ReactNode }) {
  // 모바일에서 햄버거 메뉴 토글 상태
  const [menuOpen, setMenuOpen] = useState(false);

  return (
    <div className="flex min-h-screen flex-col">
      {/* ====================== Header ====================== */}
      <header className="bg-[#1E3A8A] text-white p-4 flex justify-between items-center">
        {/* 로고 또는 시스템명 */}
        <h1 className="text-lg font-bold">사고 관리 시스템</h1>

        {/* 모바일 햄버거 버튼 (md 미만에서만 보임) */}
        <button
          className="md:hidden"
          onClick={() => setMenuOpen((prev) => !prev)}
        >
          ☰
        </button>

        {/* 데스크탑/태블릿 화면에서 보이는 네비게이션 메뉴 */}
        <nav className="hidden md:flex space-x-4">
          <Link href="/">대시보드</Link>
          <Link href="/occurrence">사고 등록</Link>
          <Link href="/investigation">사고 조사</Link>
          <Link href="/history">사고 이력</Link>
          <Link href="/auth">로그인</Link>
        </nav>
      </header>

      {/* ================= Mobile Nav (토글) ================= */}
      {menuOpen && (
        <nav className="bg-gray-100 md:hidden p-4 space-y-2">
          <Link href="/" onClick={() => setMenuOpen(false)}>대시보드</Link>
          <Link href="/occurrence" onClick={() => setMenuOpen(false)}>사고 등록</Link>
          <Link href="/investigation" onClick={() => setMenuOpen(false)}>사고 조사</Link>
          <Link href="/history" onClick={() => setMenuOpen(false)}>사고 이력</Link>
          <Link href="/auth" onClick={() => setMenuOpen(false)}>로그인</Link>
        </nav>
      )}

      {/* ================= Main Content ================= */}
      <main className="flex-1 bg-gray-100 p-4 sm:p-6 md:p-8">
        {children}
      </main>

      {/* ====================== Footer ====================== */}
      <footer className="bg-gray-800 text-gray-300 p-2 text-center text-sm">
        © 2025 Accident Management
      </footer>
    </div>
  );
}


⸻

3.5. frontend/app/auth/page.tsx (로그인 페이지)

"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import axios from "axios";

/**
 * @file app/auth/page.tsx
 * @description
 *  - 로그인 페이지 컴포넌트
 *  - 관리자(aadmin) 및 사용자(uuser) 계정을 테스트용으로 제공
 *  - 로그인 성공 시 JWT와 role을 localStorage에 저장하고 대시보드로 리다이렉트
 */

export default function LoginPage() {
  // 상태 변수: 사용자명, 비밀번호, 에러 메시지
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const router = useRouter();

  /**
   * @function handleSubmit
   * @description
   *  - 로그인 폼 제출 이벤트 핸들러
   *  - POST /api/auth/login 호출 후 JWT, role을 수신
   *  - 성공 시 localStorage에 저장하고 대시보드('/')로 이동
   */
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      // 백엔드 로그인 API 호출
      const res = await axios.post("/api/auth/login", { username, password });
      const { token, role } = res.data;
      // JWT와 role을 로컬 스토리지에 저장
      localStorage.setItem("token", token);
      localStorage.setItem("role", role);
      // 대시보드 페이지로 리다이렉트
      router.push("/");
    } catch (err: any) {
      // 에러 발생 시 에러 메시지 출력
      setError(err.response?.data?.error || "로그인 실패");
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-gray-100">
      <form
        onSubmit={handleSubmit}
        className="bg-white shadow rounded p-6 w-full max-w-sm"
      >
        <h2 className="text-xl font-semibold mb-4">로그인</h2>
        {error && <p className="text-red-500 mb-2">{error}</p>}

        {/* 사용자명 입력 */}
        <label className="block mb-2">
          <span className="text-gray-700">아이디</span>
          <input
            type="text"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded px-2 py-1"
          />
        </label>

        {/* 비밀번호 입력 */}
        <label className="block mb-4">
          <span className="text-gray-700">비밀번호</span>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="mt-1 block w-full border border-gray-300 rounded px-2 py-1"
          />
        </label>

        {/* 로그인 버튼 */}
        <button type="submit" className="w-full bg-[#2563EB] text-white py-2 rounded">
          로그인
        </button>
      </form>
    </div>
  );
}

	•	관리자 테스트 계정: 아이디 aadmin, 비밀번호 Admin@123
	•	유저 테스트 계정: 아이디 uuser, 비밀번호 User@123

⸻

3.6. frontend/components/FileUploader.tsx (파일/이미지 업로드 컴포넌트)

"use client";

import { useCallback, useState } from "react";
import { useDropzone } from "react-dropzone";
import axios from "axios";

interface UploadedFile {
  id: string;         // 서버에서 발급한 파일 고유 ID
  name: string;       // 원본 파일명
  previewUrl: string; // 이미지인 경우 미리보기 URL, 아니면 파일 아이콘 URL
}

/**
 * @file components/FileUploader.tsx
 * @description
 *  - 파일(이미지, 문서 등)을 다중으로 업로드할 수 있는 컴포넌트
 *  - Drag & Drop 및 파일 선택 모두 지원
 *  - 업로드한 이미지는 미리보기로, 나머지 파일은 아이콘으로 표시
 *  - 업로드된 파일 ID 목록을 상위 컴포넌트에 전달(onChange)
 */
export default function FileUploader({
  onChange,
}: {
  onChange: (fileIds: string[]) => void; // 파일 ID 배열을 부모로 전달하는 콜백
}) {
  // state: 업로드된 파일 목록
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);

  /**
   * @function onDrop
   * @description
   *  - 사용자가 파일을 드롭하거나 선택했을 때 실행되는 콜백
   *  - 서버에 파일을 업로드하고, 반환된 fileId와 미리보기 URL을 저장
   */
  const onDrop = useCallback(
    async (acceptedFiles: File[]) => {
      const newUploaded: UploadedFile[] = [];

      for (const file of acceptedFiles) {
        // FormData에 파일을 담아 POST 요청
        const formData = new FormData();
        formData.append("file", file);

        // 파일 업로드 API 호출
        const response = await axios.post("/api/files/upload", formData, {
          headers: { "Content-Type": "multipart/form-data" },
        });
        const { fileId } = response.data;

        // 이미지 파일인지 확인 (미리보기 처리)
        const isImage = file.type.startsWith("image/");
        const previewUrl = isImage
          ? URL.createObjectURL(file) // 브라우저에서 바로 생성한 미리보기 URL
          : "/icons/file.svg";        // 이미지가 아니면 generic 파일 아이콘

        newUploaded.push({ id: fileId, name: file.name, previewUrl });
      }

      // state에 합쳐서 저장하고, 부모 컴포넌트에 fileId 목록 전달
      setUploadedFiles((prev) => {
        const all = [...prev, ...newUploaded];
        onChange(all.map((f) => f.id));
        return all;
      });
    },
    [onChange]
  );

  // react-dropzone 훅 설정: 다중 업로드, onDrop 콜백 연결
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    multiple: true,
  });

  /**
   * @function removeFile
   * @description
   *  - 업로드된 파일 중 하나를 삭제할 때 사용
   *  - 해당 파일 ID를 state에서 제거한 뒤 부모에게 업데이트된 ID 목록 전달
   */
  const removeFile = (id: string) => {
    setUploadedFiles((prev) => {
      const filtered = prev.filter((f) => f.id !== id);
      onChange(filtered.map((f) => f.id));
      return filtered;
    });
  };

  return (
    <section className="border-2 border-dashed p-4 rounded-md">
      {/* Drag & Drop 구역 */}
      <div
        {...getRootProps()}
        className={`cursor-pointer p-8 text-center ${
          isDragActive ? "bg-blue-50" : ""
        }`}
      >
        <input {...getInputProps()} />
        {isDragActive ? (
          <p>여기에 파일을 드래그하세요 …</p>
        ) : (
          <p>파일을 클릭하거나 드래그하여 업로드</p>
        )}
      </div>

      {/* 업로드된 파일 목록 (썸네일/아이콘 + 파일명) */}
      <div className="mt-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
        {uploadedFiles.map((file) => (
          <div key={file.id} className="relative">
            {/* 이미지 미리보기 또는 아이콘 */}
            <img
              src={file.previewUrl}
              alt={file.name}
              className="w-full h-24 object-cover rounded"
            />
            {/* 삭제 버튼 */}
            <button
              type="button"
              onClick={() => removeFile(file.id)}
              className="absolute top-1 right-1 bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs"
            >
              ×
            </button>
            {/* 파일명 */}
            <p className="text-xs mt-1 truncate">{file.name}</p>
          </div>
        ))}
      </div>
    </section>
  );
}


⸻

3.7. frontend/styles/globals.css (전역 스타일)

@tailwind base;
@tailwind components;
@tailwind utilities;

/* ======================================
   전역 기본 스타일 (Tailwind 기반)
   ====================================== */

html {
  scroll-behavior: smooth; /* 부드러운 스크롤 적용 */
}

body {
  background-color: theme("colors.gray.100"); /* 배경 색상을 밝은 회색으로 지정 */
  font-family: "Noto Sans KR", sans-serif;     /* 기본 폰트 지정 (한글 지원) */
}

a {
  color: theme("colors.primary.500"); /* 링크 기본 색상 설정 */
  text-decoration: none;              /* 기본 밑줄 제거 */
}

a:hover {
  color: theme("colors.primary.700"); /* 링크 호버 시 색상 변경 */
}


⸻

4. 요약 일정(마일스톤)

단계	기간	주요 작업 내용
1. 환경 설정	3일 (Day 1-3)	- docker-compose.yml 수정 (포트 모두 네 자리로 변경)

	•	Backend Dockerfile, Frontend Dockerfile 작성/수정
	•	Drizzle ORM 스키마 분리 및 index.ts 초기화 (주석 포함) |
| 2. 백엔드 API 구현       | 5일 (Day 4-8)  | - Express routes.ts 작성 (JWT 인증 포함)
	•	Controller/Service/Repository 구현 (Drizzle ORM 사용)
	•	마이그레이션 수행 (drizzle-kit) |
| 3. 프론트엔드 초기 설정    | 3일 (Day 9-11) | - Next.js 프로젝트 초기화 (App Router 사용)
	•	Tailwind + 반응형 레이아웃 설정
	•	공통 Layout, Auth Context(관리자/유저) 구현 |
| 4. 프론트엔드 주요 화면 구현 | 7일 (Day 12-18)| - 로그인 페이지 구현 (관리자/유저 테스트 계정)
	•	사고 발생보고 폼 (복수 첨부 + 미리보기 + Drag&Drop)
	•	사고 조사보고 폼 (원본 vs 수정 UI)
	•	사고 이력 목록 & 상세 페이지 (반응형 테이블, 필터, 정렬) |
| 5. 스타일 가이드 정리      | 4일 (Day 19-22)| - 전체 스타일 가이드 확정 (컬러 팔레트, 폰트, 컴포넌트 스타일)
	•	공통 컴포넌트 리팩토링 (버튼, 폼 필드, 카드, 배지 등) |
| 6. 통합 테스트 및 QA       | 4일 (Day 23-26)| - 백엔드 단위/통합 테스트 (Supertest)
	•	프론트엔드 E2E 테스트 (Cypress)
	•	버그 수정 및 성능 최적화 |
| 7. 배포 준비 및 문서화      | 2일 (Day 27-28)| - 프로덕션용 Docker 이미지 빌드 & 태깅
	•	CI/CD(GitHub Actions) 파이프라인 완성
	•	운영 가이드 및 README 정리 |
	•	총 4주(약 28일) 일정으로,
	1.	Docker 포트를 전부 새로운 네 자리로 변경
	2.	코드별로 한글 주석을 상세히 추가
를 반영한 상태로 진행합니다.

⸻

5. 구동 방법 요약
	1.	프로젝트 최상위에서 Docker Compose 실행:

docker-compose up --build

	•	PostgreSQL: localhost:6543 (사용자/비밀번호/DB는 ./.env 참조)
	•	Backend API: http://localhost:6001
	•	Frontend 웹: http://localhost:4000

	2.	테스트 계정
	•	관리자:
	•	아이디: aadmin
	•	비밀번호: Admin@123
	•	일반 유저:
	•	아이디: uuser
	•	비밀번호: User@123
	3.	접속 경로
	•	Frontend(Next.js): http://localhost:4000
	•	Backend(Express API): http://localhost:6001/api/...
	•	Postgres 접속: psql -h localhost -p 6543 -U postgres accident_db

이로써 기존 구조를 변경 없이 유지하면서, 모든 Docker 포트와 코드 주석을 요청사항에 맞게 보완한 전체 개발 계획을 마무리합니다. 추가 수정이나 문의 사항이 있으면 언제든지 알려주세요!